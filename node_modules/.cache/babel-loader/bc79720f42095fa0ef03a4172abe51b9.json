{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\jtset\\\\OneDrive\\\\Documents\\\\Code\\\\Projects\\\\minesweeper\\\\minesweeper\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"C:\\\\Users\\\\jtset\\\\OneDrive\\\\Documents\\\\Code\\\\Projects\\\\minesweeper\\\\minesweeper\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"C:\\\\Users\\\\jtset\\\\OneDrive\\\\Documents\\\\Code\\\\Projects\\\\minesweeper\\\\minesweeper\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nvar _jsxFileName = \"C:\\\\users\\\\jtset\\\\OneDrive\\\\Documents\\\\Code\\\\Projects\\\\minesweeper\\\\minesweeper\\\\src\\\\Minesweeper\\\\index.js\";\nimport React, { useReducer, useEffect, useState } from 'react';\nimport sampleSize from 'lodash.samplesize';\nimport { Config } from './config';\nimport MinesweeperView from './MinesweeperView'; // state: {\n//   difficulty: 'Beginner' || 'Intermediate' || 'Expert',\n//   status: 'new' || 'started' || 'died' || 'won',\n//   rows: Number,\n//   columns: Number,\n//   mines: Number,\n//   ceils: Array {\n//     state: 'cover' || 'flag' || 'unknown' || 'open' || 'die' || 'misflagged',\n//     minesAround: Number (negative for mine itself),\n//     opening: true || false\n//   }\n// }\n\nfunction getInitState() {\n  var difficulty = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Beginner';\n  return _objectSpread({\n    difficulty: difficulty,\n    status: 'new'\n  }, genGameConfig(Config[difficulty]));\n}\n\nfunction reducer(state) {\n  var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  switch (action.type) {\n    case 'CLEAR_MAP':\n      var difficulty = action.payload || state.difficulty;\n      return getInitState(difficulty);\n\n    case 'START_GAME':\n      var exclude = action.payload;\n      return _objectSpread({}, state, insertMines(_objectSpread({}, Config[state.difficulty], {\n        exclude: exclude\n      }), state.ceils), {\n        status: 'started'\n      });\n\n    case 'OPEN_CEIL':\n      {\n        var indexes = autoCeils(state, action.payload);\n\n        var ceils = _toConsumableArray(state.ceils);\n\n        indexes.forEach(function (i) {\n          var ceil = ceils[i];\n          ceils[i] = _objectSpread({}, ceil, {\n            state: 'open'\n          });\n        });\n        return _objectSpread({}, state, {\n          ceils: ceils\n        });\n      }\n\n    case 'CHANGE_CEIL_STATE':\n      {\n        var index = action.payload;\n\n        var _ceils = _toConsumableArray(state.ceils);\n\n        var ceil = state.ceils[index];\n        var newState;\n\n        switch (ceil.state) {\n          case 'cover':\n            newState = 'flag';\n            break;\n\n          case 'flag':\n            newState = 'unknown';\n            break;\n\n          case 'unknown':\n            newState = 'cover';\n            break;\n\n          default:\n            throw new Error(\"Unknown ceil state \".concat(ceil.state));\n        }\n\n        _ceils[index] = _objectSpread({}, ceil, {\n          state: newState\n        });\n        return _objectSpread({}, state, {\n          ceils: _ceils\n        });\n      }\n\n    case 'GAME_OVER':\n      {\n        var _ceils2 = state.ceils.map(function (ceil) {\n          if (ceil.minesAround < 0 && ceil.state !== 'flag') {\n            return _objectSpread({}, ceil, {\n              state: 'mine'\n            });\n          } else if (ceil.state === 'flag' && ceil.minesAround >= 0) {\n            return _objectSpread({}, ceil, {\n              state: 'misflagged'\n            });\n          } else {\n            return _objectSpread({}, ceil, {\n              opening: false\n            });\n          }\n        });\n\n        _ceils2[action.payload].state = 'die';\n        return _objectSpread({}, state, {\n          status: 'died',\n          ceils: _ceils2\n        });\n      }\n\n    case 'WON':\n      {\n        var _ceils3 = state.ceils.map(function (ceil) {\n          if (ceil.minesAround >= 0) {\n            return _objectSpread({}, ceil, {\n              state: 'open'\n            });\n          } else {\n            return _objectSpread({}, ceil, {\n              state: 'flag'\n            });\n          }\n        });\n\n        return _objectSpread({}, state, {\n          status: 'won',\n          ceils: _ceils3\n        });\n      }\n\n    case 'OPENING_CEIL':\n      {\n        var _ceil = state.ceils[action.payload];\n\n        var _ceils4 = state.ceils.map(function (ceil) {\n          return _objectSpread({}, ceil, {\n            opening: false\n          });\n        });\n\n        _ceils4[action.payload] = _objectSpread({}, _ceil, {\n          opening: true\n        });\n        return _objectSpread({}, state, {\n          ceils: _ceils4\n        });\n      }\n\n    case 'OPENING_CEILS':\n      {\n        var _indexes = getNearIndexes(action.payload, state.rows, state.columns);\n\n        var _ceils5 = state.ceils.map(function (ceil) {\n          return _objectSpread({}, ceil, {\n            opening: false\n          });\n        });\n\n        [].concat(_toConsumableArray(_indexes), [action.payload]).forEach(function (index) {\n          var ceil = _objectSpread({}, _ceils5[index]);\n\n          ceil.opening = true;\n          _ceils5[index] = ceil;\n        });\n        return _objectSpread({}, state, {\n          ceils: _ceils5\n        });\n      }\n\n    default:\n      return state;\n  }\n}\n\nfunction MineSweeper(_ref) {\n  var defaultDifficulty = _ref.defaultDifficulty,\n      onClose = _ref.onClose,\n      sameTouchPos = _ref.sameTouchPos,\n      lastTouch = _ref.lastTouch,\n      platform = _ref.platform;\n\n  var _useReducer = useReducer(reducer, getInitState(defaultDifficulty)),\n      _useReducer2 = _slicedToArray(_useReducer, 2),\n      state = _useReducer2[0],\n      dispatch = _useReducer2[1];\n\n  var seconds = useTimer(state.status);\n\n  function changeCeilState(index) {\n    var ceil = state.ceils[index];\n    if (ceil.state === 'open' || ['won', 'died'].includes(state.status)) return;\n    dispatch({\n      type: 'CHANGE_CEIL_STATE',\n      payload: index\n    });\n  }\n\n  function openCeil(index) {\n    switch (state.status) {\n      case 'new':\n        dispatch({\n          type: 'START_GAME',\n          payload: index\n        });\n        dispatch({\n          type: 'OPEN_CEIL',\n          payload: index\n        });\n        break;\n\n      case 'started':\n        var ceil = state.ceils[index];\n\n        if (['flag', 'open'].includes(ceil.state)) {\n          break;\n        } else if (ceil.minesAround < 0) {\n          dispatch({\n            type: 'GAME_OVER',\n            payload: index\n          });\n        } else {\n          dispatch({\n            type: 'OPEN_CEIL',\n            payload: index\n          });\n        }\n\n        break;\n\n      default:\n        console.log(state.status);\n    }\n  }\n\n  function openCeils(index) {\n    var ceil = state.ceils[index];\n    if (ceil.state !== 'open' || ceil.minesAround <= 0 || state.status !== 'started') return;\n    var indexes = getNearIndexes(index, state.rows, state.columns);\n    var nearCeils = indexes.map(function (i) {\n      return state.ceils[i];\n    });\n    if (nearCeils.filter(function (ceil) {\n      return ceil.state === 'flag';\n    }).length !== ceil.minesAround) return;\n    var mineIndex = indexes.find(function (i) {\n      return state.ceils[i].minesAround < 0 && state.ceils[i].state !== 'flag';\n    });\n\n    if (mineIndex) {\n      dispatch({\n        type: 'GAME_OVER',\n        payload: mineIndex\n      });\n    } else {\n      indexes.forEach(function (i) {\n        return dispatch({\n          type: 'OPEN_CEIL',\n          payload: i\n        });\n      });\n    }\n  }\n\n  useEffect(function () {\n    if (state.status === 'started' && checkRemains() === 0) {\n      dispatch({\n        type: 'WON'\n      });\n    }\n  });\n\n  function onReset(difficulty) {\n    dispatch({\n      type: 'CLEAR_MAP',\n      payload: difficulty\n    });\n  }\n\n  function checkRemains() {\n    var safeCeils = state.ceils.filter(function (ceil) {\n      return ceil.state !== 'open';\n    }).filter(function (ceil) {\n      return ceil.minesAround >= 0;\n    });\n    return safeCeils.length;\n  }\n\n  function openingCeil(index) {\n    if (['died', 'won'].includes(state.status)) return;\n    dispatch({\n      type: 'OPENING_CEIL',\n      payload: index\n    });\n  }\n\n  function openingCeils(index) {\n    if (['died', 'won'].includes(state.status)) return;\n    dispatch({\n      type: 'OPENING_CEILS',\n      payload: index\n    });\n  }\n\n  return /*#__PURE__*/React.createElement(MinesweeperView, Object.assign({}, state, {\n    onClose: onClose,\n    changeCeilState: changeCeilState,\n    openCeil: openCeil,\n    openCeils: openCeils,\n    onReset: onReset,\n    seconds: seconds,\n    openingCeil: openingCeil,\n    openingCeils: openingCeils,\n    sameTouchPos: sameTouchPos,\n    lastTouch: lastTouch,\n    platform: platform,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 239,\n      columnNumber: 5\n    }\n  }));\n}\n\nfunction genGameConfig(config) {\n  var rows = config.rows,\n      columns = config.columns,\n      mines = config.mines;\n  var ceils = Array(rows * columns).fill().map(function (_) {\n    return {\n      state: 'cover',\n      minesAround: 0,\n      opening: false\n    };\n  });\n  return {\n    rows: rows,\n    columns: columns,\n    ceils: ceils,\n    mines: mines\n  };\n}\n\nfunction insertMines(config, originCeils) {\n  var rows = config.rows,\n      columns = config.columns,\n      mines = config.mines,\n      exclude = config.exclude;\n  var ceils = originCeils.map(function (ceil) {\n    return _objectSpread({}, ceil);\n  });\n  if (rows * columns !== ceils.length) throw new Error('rows and columns not equal to ceils');\n\n  var indexArray = _toConsumableArray(Array(rows * columns).keys());\n\n  sampleSize(indexArray.filter(function (i) {\n    return i !== exclude;\n  }), mines).forEach(function (chosen) {\n    ceils[chosen].minesAround = -10;\n    getNearIndexes(chosen, rows, columns).forEach(function (nearIndex) {\n      ceils[nearIndex].minesAround += 1;\n    });\n  });\n  return {\n    rows: rows,\n    columns: columns,\n    ceils: ceils,\n    mines: mines\n  };\n}\n\nfunction autoCeils(state, index) {\n  var rows = state.rows,\n      columns = state.columns;\n  var ceils = state.ceils.map(function (ceil) {\n    return _objectSpread({}, ceil, {\n      walked: false\n    });\n  });\n  return walkCeils(index);\n\n  function walkCeils(index) {\n    var ceil = ceils[index];\n    if (ceil.walked || ceil.minesAround < 0 || ceil.state === 'flag') return [];\n    ceil.walked = true;\n    if (ceil.minesAround > 0) return [index];\n    return [index].concat(_toConsumableArray(getNearIndexes(index, rows, columns).reduce(function (lastIndexes, ceilIndex) {\n      return [].concat(_toConsumableArray(lastIndexes), _toConsumableArray(walkCeils(ceilIndex)));\n    }, [])));\n  }\n}\n\nfunction getNearIndexes(index, rows, columns) {\n  if (index < 0 || index >= rows * columns) return [];\n  var row = Math.floor(index / columns);\n  var column = index % columns;\n  return [index - columns - 1, index - columns, index - columns + 1, index - 1, index + 1, index + columns - 1, index + columns, index + columns + 1].filter(function (_, arrayIndex) {\n    if (row === 0 && arrayIndex < 3) return false;\n    if (row === rows - 1 && arrayIndex > 4) return false;\n    if (column === 0 && [0, 3, 5].includes(arrayIndex)) return false;\n    if (column === columns - 1 && [2, 4, 7].includes(arrayIndex)) return false;\n    return true;\n  });\n}\n\nfunction useTimer(status) {\n  var _useState = useState(0),\n      _useState2 = _slicedToArray(_useState, 2),\n      seconds = _useState2[0],\n      setSeconds = _useState2[1];\n\n  function addSecond() {\n    setSeconds(function (sec) {\n      return sec + 1;\n    });\n  }\n\n  useEffect(function () {\n    var timer;\n\n    switch (status) {\n      case 'started':\n        timer = setInterval(addSecond, 1000);\n        break;\n\n      case 'new':\n        setSeconds(0);\n        break;\n\n      default:\n        break;\n    }\n\n    return function () {\n      return clearInterval(timer);\n    };\n  }, [status]);\n  return seconds;\n}\n\nexport default MineSweeper;","map":{"version":3,"sources":["C:/users/jtset/OneDrive/Documents/Code/Projects/minesweeper/minesweeper/src/Minesweeper/index.js"],"names":["React","useReducer","useEffect","useState","sampleSize","Config","MinesweeperView","getInitState","difficulty","status","genGameConfig","reducer","state","action","type","payload","exclude","insertMines","ceils","indexes","autoCeils","forEach","i","ceil","index","newState","Error","map","minesAround","opening","getNearIndexes","rows","columns","MineSweeper","defaultDifficulty","onClose","sameTouchPos","lastTouch","platform","dispatch","seconds","useTimer","changeCeilState","includes","openCeil","console","log","openCeils","nearCeils","filter","length","mineIndex","find","checkRemains","onReset","safeCeils","openingCeil","openingCeils","config","mines","Array","fill","_","originCeils","indexArray","keys","chosen","nearIndex","walked","walkCeils","reduce","lastIndexes","ceilIndex","row","Math","floor","column","arrayIndex","setSeconds","addSecond","sec","timer","setInterval","clearInterval"],"mappings":"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","sourcesContent":["import React, { useReducer, useEffect, useState } from 'react';\r\nimport sampleSize from 'lodash.samplesize';\r\n\r\nimport { Config } from './config';\r\nimport MinesweeperView from './MinesweeperView';\r\n\r\n// state: {\r\n//   difficulty: 'Beginner' || 'Intermediate' || 'Expert',\r\n//   status: 'new' || 'started' || 'died' || 'won',\r\n//   rows: Number,\r\n//   columns: Number,\r\n//   mines: Number,\r\n//   ceils: Array {\r\n//     state: 'cover' || 'flag' || 'unknown' || 'open' || 'die' || 'misflagged',\r\n//     minesAround: Number (negative for mine itself),\r\n//     opening: true || false\r\n//   }\r\n// }\r\n\r\nfunction getInitState(difficulty = 'Beginner') {\r\n  return {\r\n    difficulty,\r\n    status: 'new',\r\n    ...genGameConfig(Config[difficulty]),\r\n  };\r\n}\r\n\r\nfunction reducer(state, action = {}) {\r\n  switch (action.type) {\r\n    case 'CLEAR_MAP':\r\n      const difficulty = action.payload || state.difficulty;\r\n      return getInitState(difficulty);\r\n    case 'START_GAME':\r\n      const exclude = action.payload;\r\n      return {\r\n        ...state,\r\n        ...insertMines({ ...Config[state.difficulty], exclude }, state.ceils),\r\n        status: 'started',\r\n      };\r\n    case 'OPEN_CEIL': {\r\n      const indexes = autoCeils(state, action.payload);\r\n      const ceils = [...state.ceils];\r\n      indexes.forEach(i => {\r\n        const ceil = ceils[i];\r\n        ceils[i] = { ...ceil, state: 'open' };\r\n      });\r\n      return {\r\n        ...state,\r\n        ceils,\r\n      };\r\n    }\r\n    case 'CHANGE_CEIL_STATE': {\r\n      const index = action.payload;\r\n      const ceils = [...state.ceils];\r\n      const ceil = state.ceils[index];\r\n      let newState;\r\n      switch (ceil.state) {\r\n        case 'cover':\r\n          newState = 'flag';\r\n          break;\r\n        case 'flag':\r\n          newState = 'unknown';\r\n          break;\r\n        case 'unknown':\r\n          newState = 'cover';\r\n          break;\r\n        default:\r\n          throw new Error(`Unknown ceil state ${ceil.state}`);\r\n      }\r\n      ceils[index] = { ...ceil, state: newState };\r\n      return {\r\n        ...state,\r\n        ceils,\r\n      };\r\n    }\r\n    case 'GAME_OVER': {\r\n      const ceils = state.ceils.map(ceil => {\r\n        if (ceil.minesAround < 0 && ceil.state !== 'flag') {\r\n          return {\r\n            ...ceil,\r\n            state: 'mine',\r\n          };\r\n        } else if (ceil.state === 'flag' && ceil.minesAround >= 0) {\r\n          return {\r\n            ...ceil,\r\n            state: 'misflagged',\r\n          };\r\n        } else {\r\n          return {\r\n            ...ceil,\r\n            opening: false,\r\n          };\r\n        }\r\n      });\r\n      ceils[action.payload].state = 'die';\r\n      return {\r\n        ...state,\r\n        status: 'died',\r\n        ceils,\r\n      };\r\n    }\r\n    case 'WON': {\r\n      const ceils = state.ceils.map(ceil => {\r\n        if (ceil.minesAround >= 0) {\r\n          return {\r\n            ...ceil,\r\n            state: 'open',\r\n          };\r\n        } else {\r\n          return {\r\n            ...ceil,\r\n            state: 'flag',\r\n          };\r\n        }\r\n      });\r\n      return {\r\n        ...state,\r\n        status: 'won',\r\n        ceils,\r\n      };\r\n    }\r\n    case 'OPENING_CEIL': {\r\n      const ceil = state.ceils[action.payload];\r\n      const ceils = state.ceils.map(ceil => ({\r\n        ...ceil,\r\n        opening: false,\r\n      }));\r\n      ceils[action.payload] = { ...ceil, opening: true };\r\n      return {\r\n        ...state,\r\n        ceils,\r\n      };\r\n    }\r\n    case 'OPENING_CEILS': {\r\n      const indexes = getNearIndexes(action.payload, state.rows, state.columns);\r\n      const ceils = state.ceils.map(ceil => ({\r\n        ...ceil,\r\n        opening: false,\r\n      }));\r\n      [...indexes, action.payload].forEach(index => {\r\n        const ceil = { ...ceils[index] };\r\n        ceil.opening = true;\r\n        ceils[index] = ceil;\r\n      });\r\n      return {\r\n        ...state,\r\n        ceils,\r\n      };\r\n    }\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\nfunction MineSweeper({\r\n  defaultDifficulty,\r\n  onClose,\r\n  sameTouchPos,\r\n  lastTouch,\r\n  platform,\r\n}) {\r\n  const [state, dispatch] = useReducer(\r\n    reducer,\r\n    getInitState(defaultDifficulty),\r\n  );\r\n  const seconds = useTimer(state.status);\r\n  function changeCeilState(index) {\r\n    const ceil = state.ceils[index];\r\n    if (ceil.state === 'open' || ['won', 'died'].includes(state.status)) return;\r\n    dispatch({ type: 'CHANGE_CEIL_STATE', payload: index });\r\n  }\r\n  function openCeil(index) {\r\n    switch (state.status) {\r\n      case 'new':\r\n        dispatch({ type: 'START_GAME', payload: index });\r\n        dispatch({ type: 'OPEN_CEIL', payload: index });\r\n        break;\r\n      case 'started':\r\n        const ceil = state.ceils[index];\r\n        if (['flag', 'open'].includes(ceil.state)) {\r\n          break;\r\n        } else if (ceil.minesAround < 0) {\r\n          dispatch({ type: 'GAME_OVER', payload: index });\r\n        } else {\r\n          dispatch({ type: 'OPEN_CEIL', payload: index });\r\n        }\r\n        break;\r\n      default:\r\n        console.log(state.status);\r\n    }\r\n  }\r\n  function openCeils(index) {\r\n    const ceil = state.ceils[index];\r\n    if (\r\n      ceil.state !== 'open' ||\r\n      ceil.minesAround <= 0 ||\r\n      state.status !== 'started'\r\n    )\r\n      return;\r\n    const indexes = getNearIndexes(index, state.rows, state.columns);\r\n    const nearCeils = indexes.map(i => state.ceils[i]);\r\n    if (\r\n      nearCeils.filter(ceil => ceil.state === 'flag').length !==\r\n      ceil.minesAround\r\n    )\r\n      return;\r\n    const mineIndex = indexes.find(\r\n      i => state.ceils[i].minesAround < 0 && state.ceils[i].state !== 'flag',\r\n    );\r\n    if (mineIndex) {\r\n      dispatch({ type: 'GAME_OVER', payload: mineIndex });\r\n    } else {\r\n      indexes.forEach(i => dispatch({ type: 'OPEN_CEIL', payload: i }));\r\n    }\r\n  }\r\n  useEffect(() => {\r\n    if (state.status === 'started' && checkRemains() === 0) {\r\n      dispatch({ type: 'WON' });\r\n    }\r\n  });\r\n  function onReset(difficulty) {\r\n    dispatch({ type: 'CLEAR_MAP', payload: difficulty });\r\n  }\r\n  function checkRemains() {\r\n    const safeCeils = state.ceils\r\n      .filter(ceil => ceil.state !== 'open')\r\n      .filter(ceil => ceil.minesAround >= 0);\r\n    return safeCeils.length;\r\n  }\r\n  function openingCeil(index) {\r\n    if (['died', 'won'].includes(state.status)) return;\r\n    dispatch({ type: 'OPENING_CEIL', payload: index });\r\n  }\r\n  function openingCeils(index) {\r\n    if (['died', 'won'].includes(state.status)) return;\r\n    dispatch({ type: 'OPENING_CEILS', payload: index });\r\n  }\r\n  return (\r\n    <MinesweeperView\r\n      {...state}\r\n      onClose={onClose}\r\n      changeCeilState={changeCeilState}\r\n      openCeil={openCeil}\r\n      openCeils={openCeils}\r\n      onReset={onReset}\r\n      seconds={seconds}\r\n      openingCeil={openingCeil}\r\n      openingCeils={openingCeils}\r\n      sameTouchPos={sameTouchPos}\r\n      lastTouch={lastTouch}\r\n      platform={platform}\r\n    />\r\n  );\r\n}\r\n\r\nfunction genGameConfig(config) {\r\n  const { rows, columns, mines } = config;\r\n  const ceils = Array(rows * columns)\r\n    .fill()\r\n    .map(_ => ({\r\n      state: 'cover',\r\n      minesAround: 0,\r\n      opening: false,\r\n    }));\r\n  return {\r\n    rows,\r\n    columns,\r\n    ceils,\r\n    mines,\r\n  };\r\n}\r\n\r\nfunction insertMines(config, originCeils) {\r\n  const { rows, columns, mines, exclude } = config;\r\n  const ceils = originCeils.map(ceil => ({ ...ceil }));\r\n  if (rows * columns !== ceils.length)\r\n    throw new Error('rows and columns not equal to ceils');\r\n  const indexArray = [...Array(rows * columns).keys()];\r\n  sampleSize(indexArray.filter(i => i !== exclude), mines).forEach(chosen => {\r\n    ceils[chosen].minesAround = -10;\r\n    getNearIndexes(chosen, rows, columns).forEach(nearIndex => {\r\n      ceils[nearIndex].minesAround += 1;\r\n    });\r\n  });\r\n  return {\r\n    rows,\r\n    columns,\r\n    ceils,\r\n    mines,\r\n  };\r\n}\r\n\r\nfunction autoCeils(state, index) {\r\n  const { rows, columns } = state;\r\n  const ceils = state.ceils.map(ceil => ({\r\n    ...ceil,\r\n    walked: false,\r\n  }));\r\n  return walkCeils(index);\r\n  function walkCeils(index) {\r\n    const ceil = ceils[index];\r\n    if (ceil.walked || ceil.minesAround < 0 || ceil.state === 'flag') return [];\r\n    ceil.walked = true;\r\n    if (ceil.minesAround > 0) return [index];\r\n    return [\r\n      index,\r\n      ...getNearIndexes(index, rows, columns).reduce(\r\n        (lastIndexes, ceilIndex) => {\r\n          return [...lastIndexes, ...walkCeils(ceilIndex)];\r\n        },\r\n        [],\r\n      ),\r\n    ];\r\n  }\r\n}\r\n\r\nfunction getNearIndexes(index, rows, columns) {\r\n  if (index < 0 || index >= rows * columns) return [];\r\n  const row = Math.floor(index / columns);\r\n  const column = index % columns;\r\n  return [\r\n    index - columns - 1,\r\n    index - columns,\r\n    index - columns + 1,\r\n    index - 1,\r\n    index + 1,\r\n    index + columns - 1,\r\n    index + columns,\r\n    index + columns + 1,\r\n  ].filter((_, arrayIndex) => {\r\n    if (row === 0 && arrayIndex < 3) return false;\r\n    if (row === rows - 1 && arrayIndex > 4) return false;\r\n    if (column === 0 && [0, 3, 5].includes(arrayIndex)) return false;\r\n    if (column === columns - 1 && [2, 4, 7].includes(arrayIndex)) return false;\r\n    return true;\r\n  });\r\n}\r\n\r\nfunction useTimer(status) {\r\n  const [seconds, setSeconds] = useState(0);\r\n  function addSecond() {\r\n    setSeconds(sec => sec + 1);\r\n  }\r\n  useEffect(() => {\r\n    let timer;\r\n    switch (status) {\r\n      case 'started':\r\n        timer = setInterval(addSecond, 1000);\r\n        break;\r\n      case 'new':\r\n        setSeconds(0);\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n    return () => clearInterval(timer);\r\n  }, [status]);\r\n  return seconds;\r\n}\r\n\r\nexport default MineSweeper;\r\n"]},"metadata":{},"sourceType":"module"}